<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>程序员的浪漫</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, #ffeef2 0%, #ffe0e6 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow-x: hidden;
            overflow-y: auto;
            font-family: 'Microsoft YaHei', '微软雅黑', Arial, sans-serif;
            position: relative;
            padding: 10px;
        }

        /* 背景爱心粒子容器 */
        .particles-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
            overflow: hidden;
        }

        /* 爱心粒子样式 */
        .heart-particle {
            position: absolute;
            font-size: 20px;
            color: rgba(255, 105, 180, 0.6);
            animation: floatUp linear infinite;
            user-select: none;
        }

        /* 粒子飘动动画 */
        @keyframes floatUp {
            0% {
                transform: translateY(100vh) translateX(0) rotate(0deg);
                opacity: 0;
            }
            10% {
                opacity: 0.6;
            }
            90% {
                opacity: 0.6;
            }
            100% {
                transform: translateY(-100px) translateX(var(--drift)) rotate(360deg);
                opacity: 0;
            }
        }

        .container {
            position: relative;
            width: 90vmin;
            height: 90vmin;
            max-width: 800px;
            max-height: 800px;
            min-width: 300px;
            min-height: 300px;
            z-index: 10;
        }

        .message-box {
            position: absolute;
            width: clamp(50px, 8vw, 80px);
            height: clamp(50px, 8vw, 80px);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            font-size: clamp(10px, 1.5vw, 12px);
            color: white;
            font-weight: bold;
            padding: clamp(4px, 1vw, 8px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
            opacity: 0;
            transform: scale(0.3);
            transition: opacity 0.4s ease, transform 0.4s ease;
            word-wrap: break-word;
            cursor: pointer;
            z-index: 10;
            border: 2px solid rgba(255, 255, 255, 0.5);
            backdrop-filter: blur(2px);
        }

        /* 响应式设计 */
        @media (max-width: 768px) {
            .container {
                width: 95vmin;
                height: 95vmin;
                min-width: 280px;
                min-height: 280px;
            }

            .message-box {
                width: clamp(45px, 10vw, 70px);
                height: clamp(45px, 10vw, 70px);
                font-size: clamp(9px, 2vw, 11px);
                padding: clamp(3px, 1.5vw, 6px);
            }

            .heart-particle {
                font-size: clamp(15px, 4vw, 20px);
            }
        }

        @media (max-width: 480px) {
            .container {
                width: 98vmin;
                height: 98vmin;
                min-width: 250px;
                min-height: 250px;
            }

            .message-box {
                width: clamp(40px, 12vw, 60px);
                height: clamp(40px, 12vw, 60px);
                font-size: clamp(8px, 2.5vw, 10px);
                padding: clamp(2px, 2vw, 5px);
                border-radius: 8px;
            }
        }

        @media (max-height: 600px) {
            .container {
                height: 85vh;
                width: 85vh;
                max-height: 600px;
                max-width: 600px;
            }
        }

        .message-box.show {
            opacity: 1;
            transform: scale(1);
        }

        .message-box:hover {
            transform: scale(1.1);
            z-index: 1000;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        /* 隐藏音频元素 */
        #backgroundMusic {
            display: none;
        }
    </style>
</head>
<body>
    <div class="particles-container" id="particlesContainer"></div>
    <div class="container" id="heartContainer"></div>
    
    <!-- 背景音乐 -->
    <!-- 使用说明：取消下面 audio 标签中 source 的注释，并设置您的音乐文件路径 -->
    <audio id="backgroundMusic" loop preload="auto">
        <!-- 取消注释并设置您的音乐文件路径，例如：<source src="music.mp3" type="audio/mpeg"> -->
        <source src="一个人想着一个人 说唱版-戴羽彤,承桓.flac" type="audio/flac">
        <!-- <source src="music.ogg" type="audio/ogg"> -->
        您的浏览器不支持音频播放。
    </audio>

    <script>
        // 关心的话语数组
        const messages = [
            "我想你了",
            "记得保暖",
            "多吃水果",
            "多喝水",
            "早点休息",
            "注意身体",
            "记得吃饭",
            "不要太累",
            "照顾好自己",
            "想你",
            "爱你",
            "要开心",
            "注意安全",
            "记得想我",
            "晚安",
            "早安",
            "今天也要加油",
            "你很重要",
            "我在想你",
            "记得微笑",
            "要健康",
            "别熬夜",
            "记得开心",
            "你辛苦了",
            "要快乐",
            "记得添衣",
            "记得带伞",
            "累了就休息",
            "别太拼了",
            "我在等你",
            "想抱抱你",
            "要好好吃饭",
            "按时作息",
            "别着凉了",
            "记得运动",
            "保持好心情",
            "你是最棒的",
            "我永远支持你",
            "记得放松",
            "别忘记我",
            "要好好休息",
            "记得联系我",
            "我一直在",
            "你很珍贵",
            "要对自己好",
            "别太辛苦",
            "记得想我哦",
            "我心疼你",
            "要照顾好自己",
            "记得多休息",
            "你很重要",
            "我爱你",
            "要幸福",
            "记得开心点",
            "别累坏了",
            "我陪着你",
            "记得保暖哦",
            "要保重身体",
            "记得按时吃饭",
            "别太晚睡",
            "记得想我",
            "我在这里",
            "要开开心心",
            "记得多喝水",
            "别太忙碌",
            "记得放松心情",
            "我永远爱你",
            "要好好生活",
            "记得照顾好自己",
            "别太紧张",
            "记得微笑面对",
            "我会想你的",
            "要平安健康",
            "记得多休息",
            "别太累着自己",
            "记得开心每一天",
            "我永远在你身边",
            "要好好爱自己",
            "记得保持好心情",
            "别太压抑",
            "记得分享快乐",
            "我会一直等你",
            "要对自己温柔",
            "记得好好生活",
            "别太焦虑",
            "记得享受当下",
            "我会陪着你"
        ];

        // 生成随机颜色（更鲜明的颜色，与淡粉色背景形成对比）
        function getRandomColor() {
            const colors = [
                '#ff1744', '#e91e63', '#c2185b', '#ad1457',
                '#ff4081', '#f50057', '#ec407a', '#d81b60',
                '#ff6ec7', '#ff1493', '#ff69b4', '#ff006e',
                '#d63384', '#dc3545', '#e83e8c', '#c2185b',
                '#ff1744', '#f50057', '#e91e63', '#c2185b',
                '#ff4081', '#ff6ec7', '#ff1493', '#ff006e'
            ];
            return colors[Math.floor(Math.random() * colors.length)];
        }

        // 获取容器实际尺寸
        function getContainerSize() {
            const container = document.getElementById('heartContainer');
            const rect = container.getBoundingClientRect();
            return {
                width: rect.width,
                height: rect.height
            };
        }

        // 爱心参数方程生成点
        function generateHeartPoints(numPoints = 100) {
            const points = [];
            const size = getContainerSize();
            const containerWidth = size.width;
            const containerHeight = size.height;
            const centerX = containerWidth / 2;
            const centerY = containerHeight / 2 + (containerHeight * 0.06); // 稍微下移，让爱心在容器中心偏下
            
            // 先计算爱心方程的实际范围，以确定合适的缩放比例
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;
            
            // 采样更多点来确定范围
            for (let i = 0; i < 1000; i++) {
                const t = (i / 1000) * 2 * Math.PI;
                const x = 16 * Math.pow(Math.sin(t), 3);
                const y = -(13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t));
                
                minX = Math.min(minX, x);
                maxX = Math.max(maxX, x);
                minY = Math.min(minY, y);
                maxY = Math.max(maxY, y);
            }
            
            // 计算爱心方程的实际宽度和高度
            const heartWidth = maxX - minX;
            const heartHeight = maxY - minY;
            
            // 根据容器大小计算合适的缩放比例（留出边距）
            const margin = Math.min(containerWidth, containerHeight) * 0.12; // 响应式边距
            const availableWidth = containerWidth - margin * 2;
            const availableHeight = containerHeight - margin * 2;
            
            const scaleX = availableWidth / heartWidth;
            const scaleY = availableHeight / heartHeight;
            const scale = Math.min(scaleX, scaleY); // 使用较小的缩放比例保持比例
            
            // 生成爱心路径上的点
            for (let i = 0; i < numPoints; i++) {
                const t = (i / numPoints) * 2 * Math.PI;
                // 爱心参数方程
                const x = 16 * Math.pow(Math.sin(t), 3);
                const y = -(13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t));
                
                // 转换坐标到画布中心（不进行 clamp，保持爱心形状）
                const canvasX = centerX + x * scale;
                const canvasY = centerY + y * scale;
                
                points.push({ x: canvasX, y: canvasY });
            }
            
            return points;
        }

        // 创建消息容器
        function createMessageBox(point, index, total) {
            const box = document.createElement('div');
            box.className = 'message-box';
            
            // 随机选择消息
            const randomMessage = messages[Math.floor(Math.random() * messages.length)];
            box.textContent = randomMessage;
            
            // 随机颜色
            box.style.backgroundColor = getRandomColor();
            
            // 获取消息框的实际尺寸（动态计算）
            const boxSize = getMessageBoxSize();
            
            // 设置位置（居中定位）
            box.style.left = (point.x - boxSize.width / 2) + 'px';
            box.style.top = (point.y - boxSize.height / 2) + 'px';
            
            // 计算延迟时间（让容器逐个出现）
            const delay = (index / total) * 10000; // 总共10秒完成所有动画（放慢速度）
            
            // 前5个容器立即显示，让用户知道效果正在工作
            if (index < 1) {
                setTimeout(() => {
                    box.classList.add('show');
                }, 50);
            } else {
                setTimeout(() => {
                    box.classList.add('show');
                }, delay);
            }
            
            return box;
        }

        // 创建爱心粒子
        function createHeartParticle() {
            const particle = document.createElement('div');
            particle.className = 'heart-particle';
            particle.textContent = '❤';
            
            // 随机大小
            const size = Math.random() * 15 + 15; // 15px - 30px
            particle.style.fontSize = size + 'px';
            
            // 随机颜色透明度
            const opacity = Math.random() * 0.4 + 0.3; // 0.3 - 0.7
            const colors = [
                `rgba(255, 105, 180, ${opacity})`, // 热粉色
                `rgba(255, 20, 147, ${opacity})`,   // 深粉色
                `rgba(255, 192, 203, ${opacity})`, // 粉红色
                `rgba(255, 182, 193, ${opacity})`, // 浅粉色
                `rgba(219, 112, 147, ${opacity})`  // 淡紫色
            ];
            particle.style.color = colors[Math.floor(Math.random() * colors.length)];
            
            // 使用更均匀的分布方法，将屏幕分成多个区域
            const screenWidth = window.innerWidth;
            const numZones = 10; // 将屏幕分成10个区域
            const zoneWidth = screenWidth / numZones;
            
            // 使用计数器确保均匀分布
            particleCounter++;
            const zoneIndex = particleCounter % numZones;
            
            // 在选定的区域内随机选择位置
            const zoneStart = zoneIndex * zoneWidth;
            const zoneEnd = (zoneIndex + 1) * zoneWidth;
            const randomInZone = Math.random(); // 0-1之间的随机数
            const startX = zoneStart + randomInZone * (zoneEnd - zoneStart);
            
            particle.style.left = startX + 'px';
            
            // 减小飘动距离，避免粒子偏移太多
            const drift = (Math.random() - 0.5) * 100; // -50px 到 50px（减小范围）
            particle.style.setProperty('--drift', drift + 'px');
            
            // 随机动画时长（3-8秒）
            const duration = Math.random() * 5 + 3;
            particle.style.animationDuration = duration + 's';
            
            // 随机延迟开始
            const delay = Math.random() * 2;
            particle.style.animationDelay = delay + 's';
            
            return particle;
        }

        // 粒子初始化标志
        let particlesInitialized = false;
        let particleInterval = null;
        let particleCounter = 0; // 粒子计数器，用于均匀分布

        // 初始化背景粒子
        function initParticles() {
            // 如果已经初始化，不再重复初始化
            if (particlesInitialized) {
                return;
            }
            
            const particlesContainer = document.getElementById('particlesContainer');
            const particleCount = 30; // 粒子数量
            
            // 创建初始粒子
            for (let i = 0; i < particleCount; i++) {
                const particle = createHeartParticle();
                particlesContainer.appendChild(particle);
            }
            
            // 定期创建新粒子（保持屏幕上有一定数量的粒子）
            particleInterval = setInterval(() => {
                // 移除已经移出屏幕的粒子
                const particles = particlesContainer.querySelectorAll('.heart-particle');
                particles.forEach(p => {
                    const rect = p.getBoundingClientRect();
                    if (rect.bottom < -50) {
                        p.remove();
                    }
                });
                
                // 如果粒子数量少于设定值，添加新粒子
                if (particles.length < particleCount) {
                    const newParticle = createHeartParticle();
                    particlesContainer.appendChild(newParticle);
                }
            }, 1000);
            
            particlesInitialized = true;
        }

        // 获取消息框尺寸（根据容器大小动态调整）
        function getMessageBoxSize() {
            const container = document.getElementById('heartContainer');
            const containerWidth = container.getBoundingClientRect().width;
            // 根据容器大小计算消息框尺寸
            const boxSize = Math.max(40, Math.min(80, containerWidth * 0.1));
            return {
                width: boxSize,
                height: boxSize
            };
        }

        // 清除现有消息框
        function clearMessageBoxes() {
            const container = document.getElementById('heartContainer');
            const boxes = container.querySelectorAll('.message-box');
            boxes.forEach(box => box.remove());
        }

        // 根据屏幕大小计算合适的点数
        function getOptimalPointCount() {
            const size = getContainerSize();
            const area = size.width * size.height;
            
            // 根据容器面积动态调整点数
            if (area < 200000) { // 小屏幕（约 450x450 以下）
                return 50;
            } else if (area < 400000) { // 中等屏幕（约 450x450 到 630x630）
                return 65;
            } else { // 大屏幕
                return 80;
            }
        }

        // 初始化
        function init() {
            const container = document.getElementById('heartContainer');
            
            // 清除之前的内容
            clearMessageBoxes();
            
            // 等待一帧确保容器尺寸已更新
            requestAnimationFrame(() => {
                // 在容器尺寸确定后再计算点数
                const numPoints = getOptimalPointCount();
                const points = generateHeartPoints(numPoints);
                
                console.log('生成的爱心点数:', numPoints);
                console.log('容器尺寸:', getContainerSize());
                console.log('第一个点的坐标:', points[0]);
                
                // 创建所有消息容器
                points.forEach((point, index) => {
                    const box = createMessageBox(point, index, numPoints);
                    container.appendChild(box);
                });
                
                console.log('创建的容器数量:', container.children.length);
            });
            
            // 初始化背景粒子（只初始化一次）
            initParticles();
            
            // 自动播放背景音乐
            playBackgroundMusic();
        }

        // 播放背景音乐
        function playBackgroundMusic() {
            const audio = document.getElementById('backgroundMusic');
            
            // ========== 音频文件设置 ==========
            // 请将您的音乐文件放在项目目录中，然后取消下面的注释并设置正确的路径
            // 例如：audio.src = 'music.mp3'; 或 audio.src = 'sounds/background.mp3';
            // 支持的格式：MP3, OGG, WAV 等
            
            // 取消下面这行注释并设置您的音乐文件路径：
            // audio.src = 'music.mp3';
            
            // 检查音频源是否已设置
            const hasAudioSource = audio.src && audio.src.trim() !== '';
            const sourceElement = audio.querySelector('source');
            const hasSourceSrc = sourceElement && sourceElement.src && sourceElement.src.trim() !== '';
            
            if (hasAudioSource || hasSourceSrc) {
                // 尝试自动播放
                const playPromise = audio.play();
                
                if (playPromise !== undefined) {
                    playPromise.then(() => {
                        // 播放成功
                        console.log('音乐开始播放');
                    }).catch(error => {
                        // 自动播放被阻止，需要用户交互
                        console.log('自动播放被阻止，等待用户交互');
                        // 添加点击事件监听，用户点击页面后播放
                        const playOnInteraction = () => {
                            audio.play().then(() => {
                                console.log('音乐开始播放');
                                // 移除事件监听器，避免重复绑定
                                document.removeEventListener('click', playOnInteraction);
                                document.removeEventListener('touchstart', playOnInteraction);
                            }).catch(err => {
                                console.log('播放失败:', err);
                            });
                        };
                        
                        // 监听点击和触摸事件
                        document.addEventListener('click', playOnInteraction, { once: true });
                        document.addEventListener('touchstart', playOnInteraction, { once: true });
                    });
                }
            } else {
                console.log('请设置音频文件路径');
            }
        }

        // 防抖函数
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // 窗口大小改变时重新初始化
        const resizeHandler = debounce(() => {
            init();
        }, 300);

        // 页面加载完成后初始化
        window.addEventListener('load', init);
        
        // 监听窗口大小改变
        window.addEventListener('resize', resizeHandler);
        
        // 监听方向改变（移动设备）
        window.addEventListener('orientationchange', () => {
            setTimeout(init, 500);
        });
    </script>
</body>
</html>
